<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LinkedList源码分析</title>
      <link href="/2021/08/30/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/08/30/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>本文基于<code>JDK1.8</code>。<br>看完本篇文章你将学习到：</p><ul><li><code>LinkedList</code>可以插入<code>null</code>值的原因</li><li><code>LinkedList</code>可以允许重复的原因</li><li> <code>LinkedList</code>插入快，查询慢的原因</li></ul><p>上一篇说了<code>ArrayList</code>，这篇文章主要谈谈<code>LinkedList</code>的实现。这两个集合类在我们学习或工作过程中是很常用的，某度上面随便一搜，出来的就是它们两个之间的异同点。我们知道<code>ArrayList</code>是基于动态数组的，而<code>LinkedList</code>是基于<strong>链表</strong>的。往下我会逐层剖析<code>LinkedList</code>为什么<strong>插入快，查询慢</strong>的问题。但在这之前，让我们先看看<strong>链表</strong>是什么。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>先看一下<code>链表</code>的定义：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。<br>上面描述的可能比较复杂，我们画个图理解一下：<br><img src="https://img-blog.csdnimg.cn/20210304202120762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5OTM0MjM2MTc5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在上图中，每个节点都有两个部分，即第一部分是用来保存自身的数据的，第二部分则是保存了指向下一个节点的指针。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表和单向链表最大的不同，是每个节点即维护了下一个节点的指针，也维护了上一个节点的指针。<br><img src="https://img-blog.csdnimg.cn/20210304212051619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5OTM0MjM2MTc5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><code>单向链表</code>只有后一节点指针，在节点删除，移动的时候，需要暂存前一节点，删除的时候将前一节点和后一节点连接，因为比双向链表少维护一个前节点，只在删除的时候暂存，所以比单向链表节省资源，但是增加了操作的复杂性。<br><code>双向链表</code>有前后两个节点指针，可以回溯指针，方便节点删除，移动，在做删除操作时只需要将索引节点前后两个节点连接即可，但是相比单向链表会耗费额外资源。</p></blockquote><p>总结起来一句话：双向链表就是以空间换时间。我们接下来要分析的<code>LinkedList</code>就是基于此。</p><h3 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h3><p>这里的<code>Node</code>类是<code>LinkedList</code>的一个静态内部类，也是我们上述所说双向链表中的<code>节点</code>的具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;<span class="comment">//当前节点保存的数据</span></span><br><span class="line">    Node&lt;E&gt; next;<span class="comment">//指向下一个节点的引用</span></span><br><span class="line">    Node&lt;E&gt; prev;<span class="comment">//指向上一个节点的引用</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构非常简单，也恰恰验证了上文所说，每个节点除了维护自身的数据外，还分别维护了前一节点和后一节点的引用，用图表示就是：<br><img src="https://img-blog.csdnimg.cn/20210304213541619.png" alt="在这里插入图片描述"></p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p><code>LinkedList</code>的成员变量很简单，主要有以下几个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录链表中节点的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//记录链表中第一个节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">//记录链表中最后一个节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>由于<code>LinkedList</code>继承自<code>Deque</code>，所以需要支持<code>removeFirst</code>、<code>removeLast</code>等一系列操作，所以需要记录链表中的首尾节点。</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>假设有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;String&gt;();<span class="comment">//1</span></span><br><span class="line">    list.add(<span class="string">&quot;hello&quot;</span>);<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们逐步分析以上两处代码，首先是第1处，看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><p>可以看到初始化时并没有什么特殊的操作,接着是第2处，看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//首先获取最后一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//这里创建出一个新的节点，它的前一个节点指向l,要保存的数据即传入进来的数据，后一个节点为null</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//接着将这个新节点当做链表的最后一个节点保存起来</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果刚开始最后一个节点为null，说明是第一次添加</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//否则将刚开始最后一个节点的下一个节点的引用指向新创建的节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面注释已经写得很明白了，这里总结一下：</p><ol><li>保存当前<code>LinkedList</code>的第最后一个节点</li><li>创建出一个新的节点，并将要添加的数据赋值给新节点的<code>e</code>属性，那么这个时候新节点的上一个节点就应该是一开始保存的最后一个节点，即<code>l</code></li><li>接着将<code>LinkedList</code>的<code>last</code>引用指向新创建的节点，<code>last</code>保存的是链表的最后一个节点，因为这个时候新的节点成为了最后一个节点，所以需要重新指向。</li><li>我们在第一次添加时，<code>l</code>肯定是<code>null</code>，这个时候链表中只有一个节点，那么就是新创建出来的节点，所以同时将<code>first</code>引用指向新节点(如果不是第一次添加，那么则<code>l</code>是不为空的，则需要将<code>l</code>的下一个节点的引用指向新节点)。</li></ol><p>第一次添加后，链表结构：<br><img src="https://img-blog.csdnimg.cn/20210304220449988.png#pic_center" alt="在这里插入图片描述"><br>第二次添加后，链表结构：</p><p><img src="https://img-blog.csdnimg.cn/20210304220643915.png#pic_center" alt="在这里插入图片描述"></p><h3 id="查看元素"><a href="#查看元素" class="headerlink" title="查看元素"></a>查看元素</h3><p>这里以最简单的<code>get(int index)</code>方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//参数合法检验</span></span><br><span class="line">checkElementIndex(index);</span><br><span class="line"><span class="comment">//node方法返回节点，获取该节点保存的值并返回</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//size &gt;&gt; 1 相当于size / 2 位运算比较高效，不需要转换为10进制计算</span></span><br><span class="line"><span class="comment">//index如果小于链表大小的一半，则从头遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//index如果大于等于链表大小的一半，则从尾部遍历</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就体现出了双向链表的好处了。双向链表增加了一点点的空间消耗（每个<code>Node</code>里面还要维护它的前置<code>Node</code>的引用，相对于单链表来说空间消耗增加），同时也增加了一定的编程复杂度，却大大提升了效率。<br>举例：假设<code>LinkedList</code>中有10000个元素，如果我要找到第10000的元素，则直接从尾部开始遍历，只需要一次就能找到想要的元素。但最坏情况下如果查询第5000个元素，那么效率大打折扣。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>看完查看元素后，我们看一下如何删除一个元素，这里以按下标删除举个例子好了，下面先用图示解释一下如何删除元素。<br>假设现在链表中存在三个节点：<br><img src="https://img-blog.csdnimg.cn/20210304223216306.png#pic_center" alt="在这里插入图片描述"><br>现在需要删除中间的节点，即将第一个节点的<code>next</code>引用指向第三个节点，再将最后一个节点的<code>pre</code>引用指向第一个节点：<img src="https://img-blog.csdnimg.cn/2021030422334365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5OTM0MjM2MTc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>最终结果：<br><img src="https://img-blog.csdnimg.cn/20210304223359587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5OTM0MjM2MTc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>那么接下来看看应用到<code>LinkedList</code>具体是怎么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  checkElementIndex(index);</span><br><span class="line">  <span class="comment">//node方法和查看元素时相同</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//分别获取当前要删除节点的值、前置节点、后置节点</span></span><br><span class="line"><span class="keyword">final</span> E element = x.item;</span><br><span class="line"><span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line"><span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置节点为null，说明当前节点为首节点</span></span><br><span class="line"><span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">    first = next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//前置节点不为null，将前置节点的next指向后置节点</span></span><br><span class="line">    prev.next = next;</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    x.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置节点为null，说明当前节点为尾节点</span></span><br><span class="line"><span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    last = prev;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//后置节点不为null，将后置节点的prev指向前置节点</span></span><br><span class="line">    next.prev = prev;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    x.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">x.item = <span class="keyword">null</span>;</span><br><span class="line">size--;</span><br><span class="line">modCount++;</span><br><span class="line"><span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意一点：上面源码中的1、2、3步骤都设置为了<code>null</code>，目的是为了<code>GC</code>。</p><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>插入元素其实和上面讲的几种是一个道理，如果读者理解了上面的逻辑，插入元素也就能想通怎么回事了。</p><h3 id="LinkedList和ArrayList的区别"><a href="#LinkedList和ArrayList的区别" class="headerlink" title="LinkedList和ArrayList的区别"></a>LinkedList和ArrayList的区别</h3><p>这个问题不管是在平时面向搜索编程还是在基础面试过程中都算是老生常谈了，在这里我们逐个分析一下这两个的优缺点：</p><ul><li>插入速度比较。网上大部分说<code>LinkedList</code>插入比<code>ArrayLst</code>快。这种说法是不准确的。<code>LinkedList</code>做插入、删除的时候，慢在寻址，快在只需要改变前后<code>Node</code>的引用地址，而<code>ArrayList</code>做插入、删除的时候，慢在数组元素的批量<code>copy</code>，快在寻址。<br>所以如果待插入的元素位置在数据结构的前半段尤其是非常靠前时，<code>ArrayList</code>需要拷贝大量的元素，势必<code>LinkedList</code>会更快；如果带插入元素位置在数据结构后半段尤其是非常靠后，<code>ArrayList</code>需要拷贝的元素个数会越来越少，所以速度也会提升，甚至超过<code>LinkedList</code>。</li><li><code>ArrayLst</code>基于动态数组，所以内存上是连续的，而<code>LinkedList</code>基于链表，内存上不需要保持连续。</li><li>一般遍历<code>LinkedList</code>时最好不要使用普通for循环，而是使用迭代器代替。</li></ul><blockquote><p>我们在实际工作中，还是要根据实际情况来确定选用哪种数据结构存储数据，最好是根据需求，经过理论支撑和实际测试，最终选择合适的数据结构。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇文章介绍了<code>LinkedList</code>增加元素、查看元素、移除元素、插入元素等，以图示和源码结合的方式掌握了<code>LinkedList</code>实现原理，其内部实现就是一个双向链表，通过以空间换时间的方式提高查询的效率。</p>]]></content>
      
      
      <categories>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList源码分析</title>
      <link href="/2021/08/29/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/08/29/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>提起ArrayList,相信很多小伙伴都用过，而且还不少用。但在几年之前，我在一场面试中，面试官要求说出ArrayList的扩容机制。很显然，那个时候的我并没有关注这些，从而错过了一次机会。不过好在我还算比较喜欢搞事情的，所以今天这篇文章也算是填坑吧。<br>看完这边文章你将了解到：</p><ul><li><code>ArrayList</code>底层实现</li><li><code>ArrayList</code>为什么允许null值</li><li><code>ArrayList</code>为什么可重复</li><li><code>ArrayList</code>查询效率和插入效率对比</li></ul><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>下图是<code>ArrayList</code>的类图结构<br><img src="https://img-blog.csdnimg.cn/20210303214625117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5OTM0MjM2MTc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><code>ArrayList</code>继承于 <code>AbstractList </code>，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。<br>这里逐个分析一下这里接口的意义：</p><ul><li><code>RandomAccess </code>是一个标志接口，表明实现这个这个接口的 <code>List </code>集合是支持快速随机访问的。有兴趣可以看看<code>Collections</code>类中哪个方法用到了这个标志性接口。</li><li>实现 <code>Cloneable </code>接口并覆盖了方法<code>clone()</code>，能被克隆。</li><li>实现了java.io.Serializable 接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输（请注意，<code>ArrayList</code>的序列化是有点小特殊的，后面会讲解）。</li></ul><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>在正式进入源码分析之前，我们有必要先看看它的成员变量都有哪些，这里列举比较重要的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;  <span class="comment">// 实际元素个数</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">//真正保存元素的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//默认的初始容量大小</span></span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>我们有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、无参数直接初始化，数组大小为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、指定初始数据初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//elementData是保存数组的容器，默认为null</span></span><br><span class="line">    elementData=c.toArray();</span><br><span class="line">    <span class="comment">//如果给定的集合（c)数据有值</span></span><br><span class="line">    <span class="keyword">if</span>((size=elementData.length)!=<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//c.toArray might(incorrectly)not return Object[](see 6260652)</span></span><br><span class="line">      <span class="comment">//如果集合元素类型不是Object类型，我们会转成Object</span></span><br><span class="line">    <span class="keyword">if</span>(elementData.getClass()!=Object[].class)&#123;</span><br><span class="line">        elementData=Arrays.copyOf(elementData,size,Object].class);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//给定集合（c)无值，则默认空数组</span></span><br><span class="line">    <span class="keyword">this</span>.elementData=EMPTY_ELEMENTDATA</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、指定初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//指定的初始容量大于0，将elementData初始化为指定大小的数组</span></span><br><span class="line">   <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//否则初始化成一个空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除过源码中注释外，补充几点：</p><ol><li><code>ArrayList</code>无参构造器初始化时，默认大小是空数组，并不是大家常说的10,10是在第一次<code>add</code>的时候扩容的数组值。</li><li>使用方式二进行创建对象时，如果入参容器保存的对象不是<code>Object</code>，则转换为<code>Object</code>。<br><code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>和<code>EMPTY_ELEMENTDATA</code>又是什么鬼？它其实是定义在成员变量的两个空数组，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure>很明显问题来了，既然都是空数组，为什么要声明两个？一个不行吗？读者请先思考一下，带着疑问往下看。<h3 id="新增和扩容实现"><a href="#新增和扩容实现" class="headerlink" title="新增和扩容实现"></a>新增和扩容实现</h3>通过构造方法可以很清楚的看到，<code>ArrayList</code>的确是基于数组的，但<code>动态</code>又从何说起？<br>新增时就是给数组中添加元素，主要分为两步走：</li><li>判断是否需要扩容，如果需要扩容执行扩容操作；</li><li>直接赋值。<br>对应源码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//确保数组大小是否足够，不够执行扩容，size为当前数组元素个数，判断size+1是因为后面还要size++</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">//1</span></span><br><span class="line">    elementData[size++] = e;<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>我们先来看一下扩容部分的源码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//先调用calculateCapacity计算容量</span></span><br><span class="line">  ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果当前数组还是个空数组，也就是他用过无参构造去初始化的</span></span><br><span class="line">  <span class="comment">//那么直接返回DEFAULT_CAPACITY，即10</span></span><br><span class="line">  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前容量已经大于当前数组的长度了，说明需要去扩容了</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="comment">//oldCapacity&gt;&gt;1是把oldCapacity除以2的意思</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity=oldCapacity+(oldCapacity&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//如果扩容后的值&lt;我们的期望值，扩容后的值就等于我们的期望值</span></span><br><span class="line">  <span class="keyword">if</span>(newCapacity-minCapacity&lt;<span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line">  <span class="comment">//如果扩容后的值&gt;jvm所能分配的数组的最大值，那么就用Integer的最大值</span></span><br><span class="line">  <span class="keyword">if</span>(newCapacity-MAX_ARRAY_SIZE&gt;<span class="number">0</span>)</span><br><span class="line">    elementData=Arrays.copyOf(elementData,newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注释相对来说已经比较详细了，这里需要注意以下几点：</li><li>上面有个问题是为什么需要声明两个空数组。我们在看到上面源码的时候有一个方法为<code>calculateCapacity</code>，这个方法内部逻辑只有在通过无参构造初始化<code>ArrayList</code>的时候才会改变将要返回的<code>minCapacity</code>。而返回的这个值将会决定下面的数组是否需要扩容。如果我们通过指定大小的方式初始化<code>ArrayList</code>并指定大小为0，这说明我们需要的就是一个空的<code>ArrayList</code>，不需要去扩容，你细品；</li><li>新增时，没有对值进行校验，所以新增值可以为<code>null</code>，且没有做重复值判断，所以元素可以<code>重复</code>；</li><li>ArrayList中的数组的最大值是<code>Integer.MAX_VALUE</code>，超过这个值，<code>JVM</code>就不会给数组分配<br>内存空间了；</li><li>扩容是原来容量大小+容量大小的一半，简单说就是扩容后的大小是原来容量的1.5倍。</li></ol><p>扩容完成之后，就是简单的赋值了，赋值时并没有加锁，所以是线程<code>不安全</code>的。</p><h3 id="扩容的本质"><a href="#扩容的本质" class="headerlink" title="扩容的本质"></a>扩容的本质</h3><p>在<code>grow</code>方法的最后，扩容是通过<code>Arrays.copyOf(elementData,newCapacity);</code>这行代码实现的。这个方法实际上调用的方法是我们经常使用的<code>System.arraycopy</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> src 被拷贝的数组</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> srcPos 从数组那里开始</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> destPos从目标数组那个索引位置开始拷贝</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> length 拷贝的长度</span></span><br><span class="line"><span class="comment">*此方法是没有返回值的，通过dest的引用进行传值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos,Object dest, <span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法是一个<code>native</code>方法，虽然不能看到方法内部的具体实现，但通过参数也可以管中窥豹。这个方法会移动元素。所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。由于数组又是一块连续的内存空间，能够根据索引快速访问元素。<br>上面也就解释了一开始那个问题：<code>ArrayList</code>为什么插入慢，查询快。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>ArrayList</code>有多种删除方法，这里以根据值删除的方式进行说明(其他原理类似)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果要删除的值是null,删除第一个是null的值</span></span><br><span class="line">  <span class="keyword">if</span>(o==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index=<span class="number">0</span>;index&lt;size;index++)</span><br><span class="line">      <span class="keyword">if</span>(elementData[index]==<span class="keyword">null</span>)&#123;</span><br><span class="line">        fastRemove(index)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果要删除的值不为null,找到第一个和要删除的值相等的删除</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index=<span class="number">0</span>;index&lt;size;index++)</span><br><span class="line">      <span class="comment">//这里是根据 equals来判断值相等的，相等后再根据索引位置进行删除</span></span><br><span class="line">      <span class="comment">//所以根据对象删除时，一般来说，如果你确定要删除的是某一类的业务对象，则需要重写equals</span></span><br><span class="line">      <span class="keyword">if</span>(o.equals(elementData[index])&#123;</span><br><span class="line">        fastRemove(index)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心其实是<code>fastRemove</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">  <span class="comment">//记录数组的结构要发生变动了</span></span><br><span class="line">  nodCount++;</span><br><span class="line">  <span class="comment">//numMoved表示删除index位置的元素后，需要从index后移动多少个元素到前面去</span></span><br><span class="line">  <span class="comment">//减1的原因，是因为size从1开始算起，index从0开始算起</span></span><br><span class="line">  <span class="keyword">int</span> numMoved=size-index-<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(numMoved&gt;<span class="number">0</span>)</span><br><span class="line">    <span class="comment">//从index+1位置开始被拷贝，拷贝的起始位置是index,长度是numMoved</span></span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">  <span class="comment">//数组最后一个位置赋值null,帮助GC(没有引用则自动回收了)</span></span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中，我们可以看出，某一个元素被删除后，为了维护数组结构，我们都会把数组后面的元素往前移动，同时释放最后一个引用，便于回收。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要从ArrayList的源码入手，分别从初始化、新增、扩容、删除四个方面展开学习。我们发现ArrayList内部其实就是围绕了一个数组，在数组容量不足时将数组扩容至更大，所以也就自然被称作基于<code>动态数组</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
